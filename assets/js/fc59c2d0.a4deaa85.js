"use strict";(self.webpackChunkfields_docs=self.webpackChunkfields_docs||[]).push([[886],{3905:function(e,t,i){i.d(t,{Zo:function(){return c},kt:function(){return f}});var n=i(7294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,n,r=function(e,t){if(null==e)return{};var i,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var i=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(i),f=r,y=u["".concat(s,".").concat(f)]||u[f]||d[f]||a;return i?n.createElement(y,o(o({ref:t},c),{},{components:i})):n.createElement(y,o({ref:t},c))}));function f(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=i.length,o=new Array(a);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<a;p++)o[p]=i[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,i)}u.displayName="MDXCreateElement"},3796:function(e,t,i){i.r(t),i.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return d}});var n=i(7462),r=i(3366),a=(i(7294),i(3905)),o=["components"],l={},s="FailWith",p={unversionedId:"fail-with",id:"fail-with",title:"FailWith",description:"Fields has capability for user to use his own error type and this raises question how should library know for standart validation which error to use? FailWith* typeclasses gives this library ability to fail with specific errors.",source:"@site/../fields-docs/target/mdoc/fail-with.md",sourceDirName:".",slug:"/fail-with",permalink:"/fields/docs/fail-with",draft:!1,editUrl:"https://github.com/jap-company/fields/tree/master/docs/fail-with.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ValidationPolicy",permalink:"/fields/docs/validation-policy"},next:{title:"Syntax",permalink:"/fields/docs/validation-syntax"}},c={},d=[],u={toc:d};function f(e){var t=e.components,i=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"failwith"},"FailWith"),(0,a.kt)("p",null,"Fields has capability for user to use his own error type and this raises question how should library know for standart validation which error to use? ",(0,a.kt)("inlineCode",{parentName:"p"},"FailWith*")," typeclasses gives this library ability to fail with specific errors.\nThis way you do not need to define all mappings to start using library if you do not intend to use some validation syntax."),(0,a.kt)("p",null,"Here is list of available typeclasses:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"trait FailWith[E]\n    extends FailWithMessage[E]\n    with FailWithCompare[E]\n    with FailWithInvalid[E]\n    with FailWithEmpty[E]\n    with FailWithNonEmpty[E]\n    with FailWithMinSize[E]\n    with FailWithMaxSize[E]\n    with FailWithOneOf[E]\n")),(0,a.kt)("p",null,"If you want to have all syntax working you can extends ",(0,a.kt)("inlineCode",{parentName:"p"},"FailWith")," and not specific traits and implement the mapping.\nHere is example FailWith","[String]"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"implicit object FailWithValidationType extends FailWith[String] {\n    def invalid[A](field: Field[A]): String                                                = ValidationTypes.Invalid\n    def empty[A](field: Field[A]): String                                                  = ValidationTypes.Empty\n    def nonEmpty[A](field: Field[A]): String                                               = ValidationTypes.NonEmpty\n    def minSize[A](size: Int)(field: Field[A]): String                                     = ValidationTypes.MinSize\n    def maxSize[A](size: Int)(field: Field[A]): String                                     = ValidationTypes.MaxSize\n    def oneOf[A](variants: Seq[A])(field: Field[A]): String                                = ValidationTypes.OneOf\n    def message[A](error: String, message: Option[String])(field: Field[A]): String        = error\n    def compare[A](operation: CompareOperation, compared: String)(field: Field[A]): String =\n        operation match {\n            case CompareOperation.Equal        => ValidationTypes.Equal\n            case CompareOperation.NotEqual     => ValidationTypes.NotEqual\n            case CompareOperation.Greater      => ValidationTypes.Greater\n            case CompareOperation.GreaterEqual => ValidationTypes.GreaterEqual\n            case CompareOperation.Less         => ValidationTypes.Less\n            case CompareOperation.LessEqual    => ValidationTypes.LessEqual\n        }\n}\n")))}f.isMDXComponent=!0}}]);